# Generated by Django 4.0.8 on 2023-01-09 20:45

from django.db import migrations

SQL = """
----------------------------------------------------------------------
-- Handles insertion of flow runs
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_insert() RETURNS TRIGGER AS $$
DECLARE
    p INT;
    _path_json JSONB;
    _path_len INT;
BEGIN
    -- increment node count at current node in this path if this is an active run
    IF NEW.status IN ('A', 'W') AND NEW.current_node_uuid IS NOT NULL THEN
        PERFORM temba_insert_flownodecount(NEW.flow_id, NEW.current_node_uuid, 1);
    END IF;

    -- nothing more to do if path is empty
    IF NEW.path IS NULL OR NEW.path = '[]' THEN RETURN NULL; END IF;

    -- parse path as JSON
    _path_json := NEW.path::json;
    _path_len := jsonb_array_length(_path_json);

    -- for each step in the path, increment the path count, and record a recent run
    p := 1;
    LOOP
        EXIT WHEN p >= _path_len;

        PERFORM temba_insert_flowpathcount(
            NEW.flow_id,
            UUID(_path_json->(p-1)->>'exit_uuid'),
            UUID(_path_json->p->>'node_uuid'),
            timestamptz(_path_json->p->>'arrived_on'),
            1
        );
        p := p + 1;
    END LOOP;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------------
-- Handles changes to a run's status
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_status_change() RETURNS TRIGGER AS $$
BEGIN
    -- restrict changes
    IF OLD.status NOT IN ('A', 'W') AND NEW.status IN ('A', 'W') THEN RAISE EXCEPTION 'Cannot restart an exited flow run'; END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------------
-- Handles deletion of flow runs
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_delete() RETURNS TRIGGER AS $$
DECLARE
    p INT;
    _path_json JSONB;
    _path_len INT;
BEGIN
    -- if we're deleting a run which is sitting at a node, decrement that node's count
    IF OLD.status IN ('A', 'W') AND OLD.current_node_uuid IS NOT NULL THEN
        PERFORM temba_insert_flownodecount(OLD.flow_id, OLD.current_node_uuid, -1);
    END IF;

    -- if this is a user delete then remove from results
    IF OLD.delete_from_results THEN
        PERFORM temba_update_category_counts(OLD.flow_id, NULL, OLD.results::json);

        -- nothing more to do if path was empty
        IF OLD.path IS NULL OR OLD.path = '[]' THEN RETURN NULL; END IF;

        -- parse path as JSON
        _path_json := OLD.path::json;
        _path_len := jsonb_array_length(_path_json);

        -- for each step in the path, decrement the path count
        p := 1;
        LOOP
            EXIT WHEN p >= _path_len;

            -- it's possible that steps from old flows don't have exit_uuid
            IF (_path_json->(p-1)->'exit_uuid') IS NOT NULL THEN
                PERFORM temba_insert_flowpathcount(
                    OLD.flow_id,
                    UUID(_path_json->(p-1)->>'exit_uuid'),
                    UUID(_path_json->p->>'node_uuid'),
                    timestamptz(_path_json->p->>'arrived_on'),
                    -1
                );
            END IF;

            p := p + 1;
        END LOOP;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP FUNCTION temba_insert_flowrunstatuscount(INT, CHAR(1), INT);

DROP INDEX IF EXISTS flows_flowruncount_unsquashed;
"""


class Migration(migrations.Migration):

    dependencies = [
        ("flows", "0309_alter_flow_base_language"),
    ]

    operations = [migrations.RunSQL(SQL)]
