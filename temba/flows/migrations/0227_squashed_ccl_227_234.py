# Generated by Django 2.2.4 on 2020-12-11 12:24

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion
import django.utils.timezone
import temba.utils.json
import temba.utils.models
import uuid

from temba.flows.merging import GraphDifferenceMap, Graph


def recheck_origin_uuids_and_update_path_counts(apps, schema_editor):
    db_alias = schema_editor.connection.alias
    MergeFlowsTask = apps.get_model("flows", "MergeFlowsTask")
    FlowPathCount = apps.get_model("flows", "FlowPathCount")
    FlowPathRecentRun = apps.get_model("flows", "FlowPathRecentRun")
    tasks = MergeFlowsTask.objects.using(db_alias).filter(status="C")
    tasks_count = len(tasks)
    for index, task in enumerate(tasks, start=1):
        print(f"Fixing path counts for task {task.uuid} ({index}/{tasks_count})")
        source_definition = task.source.revisions.order_by("revision").last().definition
        target_definition = task.target.revisions.order_by("revision").last().definition

        target_exit_uuids = []
        target_node_uuids = []
        for node in target_definition.get("nodes", []):
            target_node_uuids.append(node.get("uuid"))
            target_exit_uuids.extend([exit_.get("uuid") for exit_ in node.get("exits", [])])

        mistaken_path_counts = task.target.path_counts.exclude(
            from_uuid__in=target_exit_uuids, to_uuid__in=target_node_uuids
        )
        mistaken_path_runs_counts = (
            FlowPathRecentRun.objects.using(db_alias)
            .filter(run__flow=task.target)
            .exclude(from_uuid__in=target_exit_uuids, to_uuid__in=target_node_uuids)
        )

        if mistaken_path_counts or mistaken_path_runs_counts:
            diff_map = GraphDifferenceMap(Graph(resource=source_definition), Graph(resource=target_definition))
            diff_map.compare_graphs()
            origin_node_uuids = {node_uuid: node.uuid for node_uuid, node in diff_map.diff_nodes_origin_map.items()}
            origin_exit_uuids = {
                origin_uuid: new_uuid
                for node in diff_map.diff_nodes_map.values()
                for origin_uuid, new_uuid in node.origin_exits_map.items()
            }
            updated_path_counts = []
            for path_count in mistaken_path_counts:
                path_count.from_uuid = origin_exit_uuids.get(str(path_count.from_uuid), path_count.from_uuid)
                path_count.to_uuid = origin_node_uuids.get(str(path_count.to_uuid), path_count.to_uuid)
                updated_path_counts.append(path_count)

            FlowPathCount.objects.using(db_alias).bulk_update(updated_path_counts, ["from_uuid", "to_uuid"])
            print(f"(FlowPathCount) Updated {len(updated_path_counts)} rows.")

            updated_path_runs_count, chunk_size, chunk_counter = [], 20000, 0
            for path_count in mistaken_path_runs_counts:
                path_count.from_uuid = origin_exit_uuids.get(str(path_count.from_uuid), path_count.from_uuid)
                path_count.to_uuid = origin_node_uuids.get(str(path_count.to_uuid), path_count.to_uuid)
                updated_path_runs_count.append(path_count)
                chunk_counter += 1
                if chunk_counter == chunk_size:
                    chunk_counter = 0
                    FlowPathRecentRun.objects.using(db_alias).bulk_update(
                        updated_path_runs_count, ["from_uuid", "to_uuid"]
                    )
                    print(f"(FlowPathRecentRun) Updated {chunk_size} rows.")
            else:
                # Save last uncompleted chunk
                FlowPathRecentRun.objects.using(db_alias).bulk_update(
                    updated_path_runs_count, ["from_uuid", "to_uuid"]
                )
                print(f"(FlowPathRecentRun) Updated {len(updated_path_counts)} rows.")
        else:
            print("Mistaken paths were not found.")


class Migration(migrations.Migration):

    replaces = [('flows', '0227_flowimage'), ('flows', '0228_exportflowimagestask'), ('flows', '0229_auto_20200511_2018'), ('flows', '0230_flowimage_is_active'), ('flows', '0231_auto_20200622_1053'), ('flows', '0232_mergeflowstask'), ('flows', '0233_auto_20201029_1736'), ('flows', '0234_data_fix_path_counts')]

    dependencies = [
        ('flows', '0226_merge_20200313_1155'),
        ('orgs', '0058_auto_20190723_2129'),
        ('contacts', '0105_auto_20191112_2039'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='FlowImage',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_on', models.DateTimeField(blank=True, default=django.utils.timezone.now, editable=False, help_text='When this item was originally created')),
                ('modified_on', models.DateTimeField(blank=True, default=django.utils.timezone.now, editable=False, help_text='When this item was last modified')),
                ('uuid', models.UUIDField(default=uuid.uuid4, unique=True)),
                ('name', models.CharField(help_text='Image name', max_length=255)),
                ('path', models.CharField(help_text='Image URL', max_length=255)),
                ('path_thumbnail', models.CharField(help_text='Image thumbnail URL', max_length=255, null=True)),
                ('exif', models.TextField(blank=True, help_text='A JSON representation the exif', null=True)),
                ('contact', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='flow_images', to='contacts.Contact')),
                ('flow', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='flow_images', to='flows.Flow')),
                ('org', models.ForeignKey(db_index=False, on_delete=django.db.models.deletion.CASCADE, related_name='flow_images', to='orgs.Org')),
                ('is_active', models.BooleanField(default=True, help_text='Whether this item is active, use this instead of deleting')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='ExportFlowImagesTask',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(default=True, help_text='Whether this item is active, use this instead of deleting')),
                ('created_on', models.DateTimeField(blank=True, default=django.utils.timezone.now, editable=False, help_text='When this item was originally created')),
                ('modified_on', models.DateTimeField(blank=True, default=django.utils.timezone.now, editable=False, help_text='When this item was last modified')),
                ('uuid', models.CharField(db_index=True, default=temba.utils.models.generate_uuid, help_text='The unique identifier for this object', max_length=36, unique=True, verbose_name='Unique Identifier')),
                ('status', models.CharField(choices=[('P', 'Pending'), ('O', 'Processing'), ('C', 'Complete'), ('F', 'Failed')], default='P', max_length=1)),
                ('files', models.TextField(help_text='Array as text of the files ID to download in a zip file')),
                ('created_by', models.ForeignKey(help_text='The user which originally created this item', on_delete=django.db.models.deletion.PROTECT, related_name='flows_exportflowimagestask_creations', to=settings.AUTH_USER_MODEL)),
                ('modified_by', models.ForeignKey(help_text='The user which last modified this item', on_delete=django.db.models.deletion.PROTECT, related_name='flows_exportflowimagestask_modifications', to=settings.AUTH_USER_MODEL)),
                ('org', models.ForeignKey(help_text='The organization of the user.', on_delete=django.db.models.deletion.PROTECT, related_name='exportflowimagestasks', to='orgs.Org')),
                ('cleaned', models.NullBooleanField(default=False, help_text='If the file was removed after downloaded')),
                ('file_downloaded', models.NullBooleanField(default=False, help_text='If the file was downloaded')),
                ('file_path', models.CharField(help_text='Path to downloadable file', max_length=255, null=True)),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='MergeFlowsTask',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(default=True, help_text='Whether this item is active, use this instead of deleting')),
                ('created_on', models.DateTimeField(auto_now_add=True)),
                ('modified_on', models.DateTimeField(auto_now=True)),
                ('uuid', models.CharField(db_index=True, default=temba.utils.models.generate_uuid, help_text='The unique identifier for this object', max_length=36, unique=True, verbose_name='Unique Identifier')),
                ('merge_name', models.CharField(help_text='New name for target flow that contain merged data.', max_length=64)),
                ('merging_metadata', temba.utils.models.JSONField(encoder=temba.utils.json.TembaEncoder, null=True)),
                ('definition', temba.utils.models.JSONField(encoder=temba.utils.json.TembaEncoder)),
                ('created_by', models.ForeignKey(help_text='The user which originally created this item', on_delete=django.db.models.deletion.PROTECT, related_name='flows_mergeflowstask_creations', to=settings.AUTH_USER_MODEL)),
                ('modified_by', models.ForeignKey(help_text='The user which last modified this item', on_delete=django.db.models.deletion.PROTECT, related_name='flows_mergeflowstask_modifications', to=settings.AUTH_USER_MODEL)),
                ('source', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='merge_targets', to='flows.Flow')),
                ('target', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='merge_sources', to='flows.Flow')),
                ('status', models.CharField(choices=[('A', 'Active'), ('P', 'Processing'), ('C', 'Completed'), ('F', 'Failed')], default='A', max_length=1)),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.RunPython(
            code=recheck_origin_uuids_and_update_path_counts,
        ),
    ]
