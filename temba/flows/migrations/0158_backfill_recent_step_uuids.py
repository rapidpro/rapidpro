# Generated by Django 1.11.6 on 2018-05-22 14:49

import iso8601

from django.db import migrations, transaction

PATH_STEP_UUID = "uuid"
PATH_NODE_UUID = "node_uuid"
PATH_ARRIVED_ON = "arrived_on"
PATH_EXIT_UUID = "exit_uuid"


def backfill_step_uuids(FlowPathRecentRun):
    recent_runs = FlowPathRecentRun.objects.filter(from_step_uuid=None, to_step_uuid=None)
    total_to_update = recent_runs.count()
    if not total_to_update:
        return

    print(f"Found {total_to_update} recent runs that need step UUIDs backfilled...")

    max_id = 0
    num_updated = 0
    while True:
        batch = list(recent_runs.filter(id__gt=max_id).select_related("run").order_by("id")[:1000])
        if not batch:
            break

        with transaction.atomic():
            for recent_run in batch:

                # this run has been deleted or maybe errored during its start
                if len(recent_run.run.path) == 0:
                    continue

                step_uuids = calculate_step_uuids(recent_run)
                if step_uuids is None:
                    continue

                recent_run.from_step_uuid = step_uuids[0]
                recent_run.to_step_uuid = step_uuids[1]
                recent_run.save(update_fields=("from_step_uuid", "to_step_uuid"))

        num_updated += len(batch)
        max_id = batch[-1].id
        print(f" > Updated {num_updated} of {total_to_update} recent runs")


def calculate_step_uuids(recent_run):
    path = recent_run.run.path

    # organize path into pairs of steps
    step_pairs = [(step1, path[s + 1]) for s, step1 in enumerate(path[:-1])]

    # find all step pairs for this flow segment
    segment_step_pairs = []
    for from_step, to_step in step_pairs:
        exit_uuid = str(recent_run.from_uuid)
        node_uuid = str(recent_run.to_uuid)
        if from_step.get(PATH_EXIT_UUID) == exit_uuid and to_step.get(PATH_NODE_UUID) == node_uuid and to_step:
            segment_step_pairs.append((from_step, to_step))

    # maybe we have a bad run, maybe we had to trim this run's path?
    if not segment_step_pairs:
        return None

    if len(segment_step_pairs) == 1:
        segment_step_pair = segment_step_pairs[0]
    else:
        # find last step pair before visited_on
        segment_step_pair = None
        for step_pair in reversed(segment_step_pairs):
            if iso8601.parse_date(step_pair[1][PATH_ARRIVED_ON]) <= recent_run.visited_on:
                segment_step_pair = step_pair
                break

        # but it's possible the times aren't quite right (e.g. surveyor runs) so if that fails use the last pair
        if not segment_step_pair:
            segment_step_pair = segment_step_pairs[-1]

    return segment_step_pair[0][PATH_STEP_UUID], segment_step_pair[1][PATH_STEP_UUID]


def apply_manual():
    from temba.flows.models import FlowPathRecentRun

    backfill_step_uuids(FlowPathRecentRun)


def apply_as_migration(apps, schema_editor):
    FlowPathRecentRun = apps.get_model("flows", "FlowPathRecentRun")
    backfill_step_uuids(FlowPathRecentRun)


def clear_migration(apps, schema_editor):
    pass


class Migration(migrations.Migration):

    dependencies = [("flows", "0157_update_path_trigger")]

    operations = [migrations.RunPython(apply_as_migration, clear_migration)]
