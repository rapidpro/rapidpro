# -*- coding: utf-8 -*-
# Generated by Django 1.11.6 on 2017-12-14 15:33
from __future__ import absolute_import, division, print_function, unicode_literals

import django.contrib.postgres.fields
from django.db import migrations, models


# there are no changes to the functions below but we need to re-add them after changing the schema of flows_flowrun
SQL = """
----------------------------------------------------------------------
-- Handles changes relating to a flow run's path
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_path_change() RETURNS TRIGGER AS $$
DECLARE
  p INT;
  _old_is_active BOOL;
  _old_path TEXT;
  _new_path TEXT;
  _old_path_json JSON;
  _new_path_json JSON;
  _old_path_len INT;
  _new_path_len INT;
BEGIN
  -- Handles one of the following changes to a flow run:
  --  1. flow path unchanged and is_active becomes false (run interrupted or expired)
  --  2. flow path added to and is_active becomes false (run completed)
  --  3. flow path added to and is_active remains true (run continues)
  --  4. deletion
  --

  -- restrict changes to runs
  IF TG_OP = 'UPDATE' THEN
    IF NEW.is_active AND NOT OLD.is_active THEN RAISE EXCEPTION 'Cannot re-activate an inactive flow run'; END IF;
    IF NOT OLD.is_active AND NEW.path != OLD.path THEN RAISE EXCEPTION 'Cannot modify path on an inactive flow run'; END IF;
  END IF;

  IF TG_OP = 'UPDATE' OR TG_OP = 'DELETE' THEN
    _old_is_active := OLD.is_active;
    _old_path := OLD.path;
  END IF;

  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    -- ignore test contacts
    IF temba_contact_is_test(NEW.contact_id) THEN RETURN NULL; END IF;

    _new_path := NEW.path;

    -- don't differentiate between empty array and NULL
    IF _old_path IS NULL THEN _old_path := '[]'; END IF;
    IF _new_path IS NULL THEN _new_path := '[]'; END IF;

    _old_path_json := _old_path::json;
    _new_path_json := _new_path::json;
    _old_path_len := json_array_length(_old_path_json);
    _new_path_len := json_array_length(_new_path_json);

    -- we don't support rewinding run paths, so the new path must be longer than the old
    IF _new_path_len < _old_path_len THEN RAISE EXCEPTION 'Cannot rewind a flow run path'; END IF;

    -- update the node counts
    IF _old_path_len > 0 AND _old_is_active THEN
      PERFORM temba_insert_flownodecount(NEW.flow_id, UUID(_old_path_json->(_old_path_len-1)->>'node_uuid'), -1);
    END IF;

    IF _new_path_len > 0 AND NEW.is_active THEN
      PERFORM temba_insert_flownodecount(NEW.flow_id, UUID(_new_path_json->(_new_path_len-1)->>'node_uuid'), 1);
    END IF;

    -- if we have old steps, we start at the end of the old path
    IF _old_path_len > 0 THEN p := _old_path_len; ELSE p := 1; END IF;

    LOOP
      EXIT WHEN p >= _new_path_len;
      PERFORM temba_insert_flowpathcount(
          NEW.flow_id,
          UUID(_new_path_json->(p-1)->>'exit_uuid'),
          UUID(_new_path_json->p->>'node_uuid'),
          timestamptz(_new_path_json->p->>'arrived_on'),
          1
      );
      p := p + 1;
    END LOOP;

  ELSIF TG_OP = 'DELETE' THEN
    -- ignore test contacts
    IF temba_contact_is_test(OLD.contact_id) THEN RETURN NULL; END IF;

    -- do nothing if path was empty
    IF _old_path IS NULL OR _old_path = '[]' THEN RETURN NULL; END IF;

    -- parse path as JSON
    _old_path_json := _old_path::json;
    _old_path_len := json_array_length(_old_path_json);

    -- decrement node count at last node in this path if this was an active run
    IF _old_is_active THEN
      PERFORM temba_insert_flownodecount(OLD.flow_id, UUID(_old_path_json->(_old_path_len-1)->>'node_uuid'), -1);
    END IF;

    -- decrement all path counts
    p := 1;
    LOOP
      EXIT WHEN p >= _old_path_len;

      -- for each step, decrement the associated path count
      PERFORM temba_insert_flowpathcount(
        OLD.flow_id,
        UUID(_old_path_json->(p-1)->>'exit_uuid'),
        UUID(_old_path_json->p->>'node_uuid'),
        timestamptz(_old_path_json->p->>'arrived_on'),
        -1
      );

      p := p + 1;
    END LOOP;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION temba_update_category_counts(_flow_id integer, new json, old json)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  DECLARE node_uuid text;
  DECLARE result_key text;
  DECLARE result_value text;
  DECLARE value_key text;
  DECLARE value_value text;
  DECLARE _new json;
  DECLARE _old json;
BEGIN
    -- look over the keys in our new results
    FOR result_key, result_value IN SELECT key, value from json_each(new)
    LOOP
        -- if its a new key, create a new count
        IF (old->result_key) IS NULL THEN
            execute temba_insert_flowcategorycount(_flow_id, result_key, new->result_key, 1);
        ELSE
            _new := new->result_key;
            _old := old->result_key;

            IF (_old->>'node_uuid') = (_new->>'node_uuid') THEN
                -- we already have this key, check if the value is newer
                IF timestamptz(_new->>'created_on') > timestamptz(_old->>'created_on') THEN
                    -- found an update to an existing key, create a negative and positive count accordingly
                    execute temba_insert_flowcategorycount(_flow_id, result_key, _old, -1);
                    execute temba_insert_flowcategorycount(_flow_id, result_key, _new, 1);
                END IF;
            ELSE
                -- the parent has changed, out with the old in with the new
                execute temba_insert_flowcategorycount(_flow_id, result_key, _old, -1);
                execute temba_insert_flowcategorycount(_flow_id, result_key, _new, 1);
            END IF;
        END IF;
    END LOOP;

    -- look over keys in our old results that might now be gone
    FOR result_key, result_value IN SELECT key, value from json_each(old)
    LOOP
        IF (new->result_key) IS NULL THEN
            -- found a key that's since been deleted, add a negation
            execute temba_insert_flowcategorycount(_flow_id, result_key, old->result_key, -1);
        END IF;
    END LOOP;
END;
$function$;

----------------------------------------------------------------------
-- Increments or decrements our counts for each exit type
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_update_flowruncount() RETURNS TRIGGER AS $$
BEGIN
  -- Table being cleared, reset all counts
  IF TG_OP = 'TRUNCATE' THEN
    TRUNCATE flows_flowruncount;
    RETURN NULL;
  END IF;

  -- FlowRun being added
  IF TG_OP = 'INSERT' THEN
     -- Is this a test contact, ignore
     IF temba_contact_is_test(NEW.contact_id) THEN
       RETURN NULL;
     END IF;

    -- Increment appropriate type
    PERFORM temba_insert_flowruncount(NEW.flow_id, NEW.exit_type, 1);

  -- FlowRun being removed
  ELSIF TG_OP = 'DELETE' THEN
     -- Is this a test contact, ignore
     IF temba_contact_is_test(OLD.contact_id) THEN
       RETURN NULL;
     END IF;

    PERFORM temba_insert_flowruncount(OLD.flow_id, OLD.exit_type, -1);

  -- Updating exit type
  ELSIF TG_OP = 'UPDATE' THEN
     -- Is this a test contact, ignore
     IF temba_contact_is_test(NEW.contact_id) THEN
       RETURN NULL;
     END IF;

    PERFORM temba_insert_flowruncount(OLD.flow_id, OLD.exit_type, -1);
    PERFORM temba_insert_flowruncount(NEW.flow_id, NEW.exit_type, 1);
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
"""


class Migration(migrations.Migration):

    dependencies = [
        ('flows', '0135_new_path_trigger'),
    ]

    operations = [
        migrations.AddField(
            model_name='flowrun',
            name='message_ids',
            field=django.contrib.postgres.fields.ArrayField(base_field=models.BigIntegerField(), help_text='The IDs of messages associated with this run', null=True, size=None),
        ),
        migrations.AddField(
            model_name='flowrun',
            name='current_node_uuid',
            field=models.UUIDField(help_text='The current node location of this run in the flow', null=True),
        ),
        migrations.RunSQL(SQL)
    ]
